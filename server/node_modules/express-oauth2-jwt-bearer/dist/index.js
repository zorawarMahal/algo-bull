'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var assert = require('assert');
var jose = require('jose');
var url = require('url');
var http = require('http');
var https = require('https');
var events = require('events');
var util = require('util');
var crypto = require('crypto');

class UnauthorizedError extends Error {
    constructor(message = 'Unauthorized') {
        super(message);
        this.status = 401;
        this.statusCode = 401;
        this.headers = { 'WWW-Authenticate': 'Bearer realm="api"' };
        this.name = this.constructor.name;
    }
}
class InvalidRequestError extends UnauthorizedError {
    constructor(message = 'Invalid Request', useErrorCode = true) {
        super(message);
        this.code = 'invalid_request';
        this.status = 400;
        this.statusCode = 400;
        if (useErrorCode) {
            this.headers = getHeaders(this.code, this.message);
        }
        else {
            this.code = '';
        }
    }
}
class InvalidTokenError extends UnauthorizedError {
    constructor(message = 'Invalid Token') {
        super(message);
        this.code = 'invalid_token';
        this.status = 401;
        this.statusCode = 401;
        this.headers = getHeaders(this.code, this.message);
    }
}
class InsufficientScopeError extends UnauthorizedError {
    constructor(scopes, message = 'Insufficient Scope') {
        super(message);
        this.code = 'insufficient_scope';
        this.status = 403;
        this.statusCode = 403;
        this.headers = getHeaders(this.code, this.message, scopes);
    }
}
class InvalidProofError extends UnauthorizedError {
    constructor(message = 'Invalid DPoP Proof') {
        super(message);
        this.code = 'invalid_dpop_proof';
        this.status = 400;
        this.statusCode = 400;
        this.headers = getHeaders(this.code, this.message);
    }
}
const getHeaders = (error, description, scopes) => ({
    'WWW-Authenticate': `Bearer realm="api", error="${error}", error_description="${description.replace(/"/g, "'")}"${(scopes && `, scope="${scopes.join(' ')}"`) || ''}`,
});

const decoder = new util.TextDecoder();
const concat = (...buffers) => {
    const size = buffers.reduce((acc, { length }) => acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
};
const protocols = {
    'https:': https.get,
    'http:': http.get,
};
const fetch = async (url, { agent, timeoutDuration: timeout }) => {
    const req = protocols[url.protocol](url.href, {
        agent,
        timeout,
    });
    const [response] = await events.once(req, 'response');
    if (response.statusCode !== 200) {
        throw new Error(`Failed to fetch ${url.href}, responded with ${response.statusCode}`);
    }
    const parts = [];
    for await (const part of response) {
        parts.push(part);
    }
    try {
        return JSON.parse(decoder.decode(concat(...parts)));
    }
    catch (err) {
        throw new Error(`Failed to parse the response from ${url.href}`);
    }
};

const OIDC_DISCOVERY = '/.well-known/openid-configuration';
const OAUTH2_DISCOVERY = '/.well-known/oauth-authorization-server';
const assertIssuer = (data) => assert.strict(data.issuer, `'issuer' not found in authorization server metadata`);
const discover = async ({ issuerBaseURL: uri, agent, timeoutDuration, }) => {
    const url$1 = new url.URL(uri);
    if (url$1.pathname.includes('/.well-known/')) {
        const data = await fetch(url$1, { agent, timeoutDuration });
        assertIssuer(data);
        return data;
    }
    const pathnames = [];
    if (url$1.pathname.endsWith('/')) {
        pathnames.push(`${url$1.pathname}${OIDC_DISCOVERY.substring(1)}`);
    }
    else {
        pathnames.push(`${url$1.pathname}${OIDC_DISCOVERY}`);
    }
    if (url$1.pathname === '/') {
        pathnames.push(`${OAUTH2_DISCOVERY}`);
    }
    else {
        pathnames.push(`${OAUTH2_DISCOVERY}${url$1.pathname}`);
    }
    for (const pathname of pathnames) {
        try {
            const wellKnownUri = new url.URL(pathname, url$1);
            const data = await fetch(wellKnownUri, {
                agent,
                timeoutDuration,
            });
            assertIssuer(data);
            return data;
        }
        catch (err) {
        }
    }
    throw new Error('Failed to fetch authorization server metadata');
};
var discovery = (opts) => {
    let discovery;
    let timestamp = 0;
    return () => {
        const now = Date.now();
        if (!discovery || now > timestamp + opts.cacheMaxAge) {
            timestamp = now;
            discovery = discover(opts).catch((e) => {
                discovery = undefined;
                throw e;
            });
        }
        return discovery;
    };
};

var getKeyFn = ({ agent, cooldownDuration, timeoutDuration, cacheMaxAge, secret }) => {
    let getKeyFn;
    let prevjwksUri;
    const secretKey = secret && crypto.createSecretKey(Buffer.from(secret));
    return (jwksUri) => {
        if (secretKey)
            return () => secretKey;
        if (!getKeyFn || prevjwksUri !== jwksUri) {
            prevjwksUri = jwksUri;
            getKeyFn = jose.createRemoteJWKSet(new URL(jwksUri), {
                agent,
                cooldownDuration,
                timeoutDuration,
                cacheMaxAge,
            });
        }
        return getKeyFn;
    };
};

var validate = (payload, header, validators) => Promise.all(Object.entries(validators).map(async ([key, validator]) => {
    const value = key === 'alg' || key === 'typ' ? header[key] : payload[key];
    if (validator === false ||
        (typeof validator === 'string' && value === validator) ||
        (typeof validator === 'function' &&
            (await validator(value, payload, header)))) {
        return;
    }
    throw new Error(`Unexpected '${key}' value`);
}));
const defaultValidators = (issuer, audience, clockTolerance, maxTokenAge, strict, allowedSigningAlgs, tokenSigningAlg) => ({
    alg: (alg) => typeof alg === 'string' &&
        alg.toLowerCase() !== 'none' &&
        (!allowedSigningAlgs || allowedSigningAlgs.includes(alg)) &&
        (!tokenSigningAlg || alg === tokenSigningAlg),
    typ: (typ) => !strict ||
        (typeof typ === 'string' &&
            typ.toLowerCase().replace(/^application\//, '') === 'at+jwt'),
    iss: (iss) => iss === issuer,
    aud: (aud) => {
        audience = typeof audience === 'string' ? [audience] : audience;
        if (typeof aud === 'string') {
            return audience.includes(aud);
        }
        if (Array.isArray(aud)) {
            return audience.some(Set.prototype.has.bind(new Set(aud)));
        }
        return false;
    },
    exp: (exp) => {
        const now = Math.floor(Date.now() / 1000);
        return typeof exp === 'number' && exp >= now - clockTolerance;
    },
    iat: (iat) => {
        if (!maxTokenAge) {
            return (iat === undefined && !strict) || typeof iat === 'number';
        }
        const now = Math.floor(Date.now() / 1000);
        return (typeof iat === 'number' &&
            iat < now + clockTolerance &&
            iat > now - clockTolerance - maxTokenAge);
    },
    sub: (sub) => (sub === undefined && !strict) || typeof sub === 'string',
    client_id: (clientId) => (clientId === undefined && !strict) || typeof clientId === 'string',
    jti: (jti) => (jti === undefined && !strict) || typeof jti === 'string',
});

const ASYMMETRIC_ALGS = [
    'RS256',
    'RS384',
    'RS512',
    'PS256',
    'PS384',
    'PS512',
    'ES256',
    'ES256K',
    'ES384',
    'ES512',
    'EdDSA',
];
const SYMMETRIC_ALGS = ['HS256', 'HS384', 'HS512'];
const jwtVerifier = ({ issuerBaseURL = process.env.ISSUER_BASE_URL, jwksUri = process.env.JWKS_URI, issuer = process.env.ISSUER, audience = process.env.AUDIENCE, secret = process.env.SECRET, tokenSigningAlg = process.env.TOKEN_SIGNING_ALG, agent, cooldownDuration = 30000, timeoutDuration = 5000, cacheMaxAge = 600000, clockTolerance = 5, maxTokenAge, strict = false, validators: customValidators, }) => {
    let validators;
    let allowedSigningAlgs;
    assert.strict(issuerBaseURL || (issuer && jwksUri) || (issuer && secret), "You must provide an 'issuerBaseURL', an 'issuer' and 'jwksUri' or an 'issuer' and 'secret'");
    assert.strict(!(secret && jwksUri), "You must not provide both a 'secret' and 'jwksUri'");
    assert.strict(audience, "An 'audience' is required to validate the 'aud' claim");
    assert.strict(!secret || (secret && tokenSigningAlg), "You must provide a 'tokenSigningAlg' for validating symmetric algorithms");
    assert.strict(secret || !tokenSigningAlg || ASYMMETRIC_ALGS.includes(tokenSigningAlg), `You must supply one of ${ASYMMETRIC_ALGS.join(', ')} for 'tokenSigningAlg' to validate asymmetrically signed tokens`);
    assert.strict(!secret || (tokenSigningAlg && SYMMETRIC_ALGS.includes(tokenSigningAlg)), `You must supply one of ${SYMMETRIC_ALGS.join(', ')} for 'tokenSigningAlg' to validate symmetrically signed tokens`);
    const getDiscovery = discovery({
        issuerBaseURL,
        agent,
        timeoutDuration,
        cacheMaxAge,
    });
    const getKeyFnGetter = getKeyFn({
        agent,
        cooldownDuration,
        timeoutDuration,
        cacheMaxAge,
        secret,
    });
    return async (jwt) => {
        try {
            if (issuerBaseURL) {
                const { jwks_uri: discoveredJwksUri, issuer: discoveredIssuer, id_token_signing_alg_values_supported: idTokenSigningAlgValuesSupported, } = await getDiscovery();
                jwksUri = jwksUri || discoveredJwksUri;
                issuer = issuer || discoveredIssuer;
                allowedSigningAlgs = idTokenSigningAlgValuesSupported;
            }
            validators || (validators = {
                ...defaultValidators(issuer, audience, clockTolerance, maxTokenAge, strict, allowedSigningAlgs, tokenSigningAlg),
                ...customValidators,
            });
            const { payload, protectedHeader: header } = await jose.jwtVerify(jwt, getKeyFnGetter(jwksUri), { clockTolerance });
            await validate(payload, header, validators);
            return { payload, header, token: jwt };
        }
        catch (e) {
            throw new InvalidTokenError(e.message);
        }
    };
};

const UNRESERVED = /[A-Za-z0-9\-._~]/;
function isJsonObject(input) {
    return (typeof input === 'object' &&
        input !== null &&
        !Array.isArray(input) &&
        !(input instanceof Map) &&
        !(input instanceof Set));
}
function normalizePercentEncodings(s) {
    return s.replace(/%[0-9a-fA-F]{2}/g, (m) => {
        const byte = parseInt(m.slice(1), 16);
        const ch = String.fromCharCode(byte);
        return UNRESERVED.test(ch) ? ch : `%${m.slice(1).toUpperCase()}`;
    });
}
function normalizeUrl(input, source) {
    const HOST_RE = /^(?:[A-Za-z0-9.-]+|\[[0-9A-Fa-f:.]+\])(?::\d{1,5})?$/;
    const PROTOCOL_IN_PATH_RE = /^\/[a-z][a-z0-9+.-]*:\/\//i;
    try {
        const url = new URL(input);
        const host = url.host;
        if (typeof host !== 'string' ||
            host.length === 0 ||
            host.includes('://') ||
            host.includes('/') ||
            host.includes('?') ||
            host.includes('#') ||
            !HOST_RE.test(host)) {
            if (source === 'request') {
                throw new InvalidRequestError('Invalid request URL: Host contains illegal characters or format');
            }
            else {
                throw new InvalidProofError('Invalid htu claim URL: Host contains illegal characters or format');
            }
        }
        if (source === 'request') {
            const path = url.pathname;
            if (path.startsWith('//')) {
                throw new InvalidRequestError(`Invalid request URL: Path must not start with "//"`);
            }
            if (PROTOCOL_IN_PATH_RE.test(path)) {
                throw new InvalidRequestError(`Invalid request URL: Path must not contain an absolute URL`);
            }
        }
        url.search = '';
        url.hash = '';
        url.pathname = normalizePercentEncodings(url.pathname);
        return url.origin + url.pathname;
    }
    catch (err) {
        if (source === 'request') {
            if (err instanceof InvalidRequestError)
                throw err;
            throw new InvalidRequestError('Invalid request URL');
        }
        else {
            if (err instanceof InvalidProofError)
                throw err;
            throw new InvalidProofError('Invalid htu claim URL');
        }
    }
}
function assertDPoPRequest(headers, accessTokenClaims) {
    if (headers.authorization === undefined ||
        headers.authorization === null ||
        !('authorization' in headers)) {
        throw new InvalidRequestError('', false);
    }
    if (typeof headers.authorization !== 'string') {
        throw new InvalidRequestError('', false);
    }
    if (!headers.authorization.toLowerCase().startsWith('dpop ')) {
        throw new InvalidRequestError('', false);
    }
    if (!('dpop' in headers)) {
        throw new InvalidRequestError('', false);
    }
    if (typeof headers.dpop !== 'string') {
        throw new InvalidRequestError('', false);
    }
    if (!headers.dpop.length) {
        throw new InvalidRequestError('', false);
    }
    if (headers.dpop.includes(',')) {
        throw new InvalidRequestError('', false);
    }
    if (accessTokenClaims) {
        const { cnf } = accessTokenClaims;
        if (!cnf) {
            throw new InvalidTokenError('JWT Access Token has no jkt confirmation claim');
        }
        if (!isJsonObject(cnf)) {
            throw new InvalidTokenError('Invalid "cnf" confirmation claim structure');
        }
        if (Object.keys(cnf).length > 1) {
            throw new InvalidTokenError('Multiple confirmation claims are not supported');
        }
        if (!('jkt' in cnf)) {
            throw new InvalidTokenError('JWT Access Token has no jkt confirmation claim');
        }
        if (typeof cnf.jkt !== 'string') {
            throw new InvalidTokenError('Malformed "jkt" confirmation claim');
        }
        if (!cnf.jkt.length) {
            throw new InvalidTokenError('Invalid "jkt" confirmation claim');
        }
    }
}
async function verifyProof(jws, supportedAlgorithms) {
    try {
        const verified = await jose.jwtVerify(jws, jose.EmbeddedJWK, {
            typ: 'dpop+jwt',
            algorithms: supportedAlgorithms,
        });
        const proofClaims = verified.payload;
        const proofHeader = verified.protectedHeader;
        return { proofClaims, proofHeader };
    }
    catch (err) {
        let message = 'Failed to verify DPoP proof';
        if (err instanceof Error) {
            message = err.message;
        }
        throw new InvalidProofError(message);
    }
}
async function verifyDPoP(options) {
    var _a;
    const { jwt, accessTokenClaims, url, headers, method, iatOffset, iatLeeway, supportedAlgorithms, } = options;
    assertDPoPRequest(headers, accessTokenClaims);
    if (!jwt || typeof jwt !== 'string') {
        throw new InvalidTokenError('Missing access token for DPoP verification');
    }
    const { proofClaims, proofHeader } = await verifyProof(headers.dpop, supportedAlgorithms);
    const { htm, htu, iat, jti, ath } = proofClaims;
    if (!iat) {
        throw new InvalidProofError('Missing "iat" claim in DPoP proof');
    }
    if (typeof iat !== 'number') {
        throw new InvalidProofError('"iat" claim must be a number');
    }
    const now = Math.floor(Date.now() / 1000);
    const min = now - iatOffset;
    const max = now + iatLeeway;
    if (iat < min || iat > max) {
        throw new InvalidProofError('DPoP proof "iat" is outside the acceptable range');
    }
    if (!htm) {
        throw new InvalidProofError('Missing "htm" in DPoP proof');
    }
    if (typeof htm !== 'string') {
        throw new InvalidProofError('Invalid "htm" claim');
    }
    if (htm.toUpperCase() !== method.toUpperCase()) {
        throw new InvalidProofError('DPoP Proof htm mismatch');
    }
    if (!htu) {
        throw new InvalidProofError('Missing "htu" in DPoP proof');
    }
    if (typeof htu !== 'string') {
        throw new InvalidProofError('Invalid "htu" claim');
    }
    if (url !== normalizeUrl(htu, 'proof')) {
        throw new InvalidProofError('DPoP Proof htu mismatch');
    }
    if (!jti) {
        throw new InvalidProofError('Missing "jti" in DPoP proof');
    }
    if (!ath) {
        throw new InvalidProofError('Missing "ath" claim in DPoP proof');
    }
    if (typeof ath !== 'string') {
        throw new InvalidProofError('Invalid "ath" claim');
    }
    const hash = crypto.createHash('sha256').update(jwt).digest();
    const encodedHash = jose.base64url.encode(hash);
    if (ath !== encodedHash) {
        throw new InvalidProofError('DPoP Proof "ath" mismatch');
    }
    const expected = await jose.calculateJwkThumbprint(proofHeader.jwk);
    if (((_a = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.cnf) === null || _a === void 0 ? void 0 : _a.jkt) !== expected) {
        throw new InvalidTokenError('JWT Access Token confirmation mismatch');
    }
}

const DEFAULT_DPOP_ENABLED = true;
const DEFAULT_DPOP_REQUIRED = false;
const DEFAULT_IAT_OFFSET = 300;
const DEFAULT_IAT_LEEWAY = 30;
function normalizeHeaders(input) {
    if (!isJsonObject(input)) {
        return {};
    }
    const headers = {};
    for (const [k, v] of Object.entries(input)) {
        if (typeof k === 'string') {
            headers[k.toLowerCase()] = v;
        }
    }
    return headers;
}
function getAuthScheme(headers) {
    const authorization = headers.authorization;
    if (typeof authorization === 'string') {
        const parts = authorization.split(' ');
        if (parts.length === 2) {
            return parts[0].toLowerCase();
        }
    }
    return undefined;
}
function assertValidDPoPOptions(dpopOptions) {
    if (dpopOptions === undefined)
        return;
    assert.strict(isJsonObject(dpopOptions), 'Invalid DPoP configuration: "dpop" must be an object');
    const { enabled, required, iatOffset, iatLeeway } = dpopOptions;
    if (enabled !== undefined) {
        assert.strict(typeof enabled === 'boolean', 'Invalid DPoP option: "enabled" must be a boolean');
    }
    if (required !== undefined) {
        assert.strict(typeof required === 'boolean', 'Invalid DPoP option: "required" must be a boolean');
    }
    if (iatOffset !== undefined) {
        assert.strict(typeof iatOffset === 'number', 'Invalid DPoP option: "iatOffset" must be a number');
        assert.strict(iatOffset >= 0, 'Invalid DPoP option: "iatOffset" must be a non-negative number');
    }
    if (iatLeeway !== undefined) {
        assert.strict(typeof iatLeeway === 'number', 'Invalid DPoP option: "iatLeeway" must be a number');
        assert.strict(iatLeeway >= 0, 'Invalid DPoP option: "iatLeeway" must be a non-negative number');
    }
    assert.strict(!(enabled === false && required === true), 'Invalid DPoP configuration: cannot set "required" to true when "enabled" is false');
}
function tokenVerifier(verifyJwt, options = {}, requestOptions) {
    var _a, _b;
    const headers = normalizeHeaders((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers) || {});
    const method = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.method;
    const query = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.query;
    const body = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.body;
    const isUrlEncoded = (_a = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.isUrlEncoded) !== null && _a !== void 0 ? _a : false;
    const authScheme = (_b = getAuthScheme(headers)) === null || _b === void 0 ? void 0 : _b.toLowerCase();
    const { dpop: { enabled: dpopEnabled = DEFAULT_DPOP_ENABLED, required: dpopRequired = DEFAULT_DPOP_REQUIRED, iatOffset = DEFAULT_IAT_OFFSET, iatLeeway = DEFAULT_IAT_LEEWAY, } = {}, } = options;
    let hasNonHeaderToken = false;
    let url = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.url;
    function validateRequestOptions() {
        if (typeof method !== 'string' || method.length === 0) {
            throw new InvalidRequestError('Invalid HTTP method received in request');
        }
        if (query && isJsonObject(query) === false) {
            throw new InvalidRequestError("Request 'query' parameter must be a valid JSON object");
        }
        if (body && isJsonObject(body) === false) {
            throw new InvalidRequestError("Request 'body' parameter must be a valid JSON object");
        }
    }
    function shouldVerifyDPoP(accessTokenClaims) {
        if (!dpopEnabled) {
            return false;
        }
        const hasDPoPHeader = 'dpop' in headers;
        const isDPoPScheme = authScheme === 'dpop';
        const hasBoundToken = 'cnf' in accessTokenClaims;
        return dpopRequired || isDPoPScheme || hasBoundToken || hasDPoPHeader;
    }
    function getToken() {
        const TOKEN_RE = /^(Bearer|DPoP) (.+)$/i;
        const auth = headers.authorization;
        let fromHeader;
        if (typeof auth === 'string') {
            const { length } = auth.split(' ');
            if (length !== 2) {
                throw new InvalidRequestError('', false);
            }
            const match = auth.match(TOKEN_RE);
            if (match) {
                fromHeader = match[2];
            }
        }
        const locations = [];
        if (fromHeader) {
            locations.push({ location: 'header', jwt: fromHeader });
        }
        if (typeof (query === null || query === void 0 ? void 0 : query.access_token) === 'string') {
            locations.push({ location: 'query', jwt: query.access_token });
        }
        if (typeof (body === null || body === void 0 ? void 0 : body.access_token) === 'string' && isUrlEncoded) {
            locations.push({ location: 'body', jwt: body.access_token });
        }
        if (locations.length === 0)
            throw new InvalidRequestError('', false);
        if (locations.length > 1)
            throw new InvalidRequestError('More than one method used for authentication');
        return locations[0];
    }
    async function verify() {
        url = normalizeUrl(url, 'request');
        validateRequestOptions();
        const { jwt, location } = getToken();
        hasNonHeaderToken = ['query', 'body'].includes(location);
        if (!dpopEnabled) {
            if (authScheme && authScheme !== 'bearer') {
                throw new InvalidRequestError('', false);
            }
        }
        else if (dpopRequired) {
            assertDPoPRequest(headers);
        }
        else {
            if (authScheme === 'dpop' && typeof headers.dpop !== 'string') {
                throw new InvalidRequestError('', false);
            }
            if (authScheme && !['dpop', 'bearer'].includes(authScheme)) {
                throw new UnauthorizedError();
            }
        }
        const verifiedJwt = await verifyJwt(jwt);
        const accessTokenClaims = verifiedJwt.payload;
        if (authScheme === 'bearer' &&
            'cnf' in accessTokenClaims &&
            dpopEnabled &&
            !dpopRequired) {
            throw new InvalidTokenError('DPoP-bound token requires the DPoP authentication scheme, not Bearer.');
        }
        if (shouldVerifyDPoP(accessTokenClaims)) {
            await verifyDPoP({
                jwt,
                accessTokenClaims,
                url,
                headers,
                method,
                iatOffset,
                iatLeeway,
                supportedAlgorithms: ASYMMETRIC_ALGS,
            });
        }
        return verifiedJwt;
    }
    function applyAuthChallenges(error, supportedAlgs = ASYMMETRIC_ALGS) {
        if (!dpopEnabled || !(error instanceof UnauthorizedError))
            return error;
        const authError = error;
        const errorCode = authError.code;
        const description = authError.message;
        const challenges = [];
        const hasBearer = authScheme === 'bearer';
        const hasDpop = authScheme === 'dpop';
        const hasErrorCode = typeof errorCode === 'string' && errorCode.length > 0;
        const safeDescription = description.replace(/"/g, "'");
        const buildChallenge = (scheme, includeError) => {
            const algs = supportedAlgs.join(' ');
            if (scheme === 'dpop') {
                return includeError
                    ? `DPoP error="${errorCode}", error_description="${safeDescription}", algs="${algs}"`
                    : `DPoP algs="${algs}"`;
            }
            else {
                return includeError
                    ? `Bearer realm="api", error="${errorCode}", error_description="${safeDescription}"`
                    : `Bearer realm="api"`;
            }
        };
        if (dpopRequired) {
            challenges.push(buildChallenge('dpop', hasErrorCode));
        }
        else {
            const mode = !hasBearer && !hasDpop ? 'none' : hasBearer ? 'bearer' : 'dpop';
            switch (mode) {
                case 'none':
                    challenges.push(buildChallenge('bearer', hasNonHeaderToken ? hasErrorCode : false));
                    challenges.push(buildChallenge('dpop', false));
                    break;
                case 'bearer':
                    challenges.push(buildChallenge('bearer', hasErrorCode));
                    challenges.push(buildChallenge('dpop', false));
                    break;
                case 'dpop':
                    challenges.push(buildChallenge('bearer', false));
                    challenges.push(buildChallenge('dpop', hasErrorCode));
                    break;
            }
        }
        if (challenges.length > 0) {
            error.headers = {
                'WWW-Authenticate': challenges.join(', '),
            };
        }
        return error;
    }
    return {
        shouldVerifyDPoP,
        getToken,
        verify,
        applyAuthChallenges,
    };
}

const checkJSONPrimitive = (value) => {
    if (typeof value !== 'string' &&
        typeof value !== 'number' &&
        typeof value !== 'boolean' &&
        value !== null) {
        throw new TypeError("'expected' must be a string, number, boolean or null");
    }
};
const isClaimIncluded = (claim, expected, matchAll = true) => (payload) => {
    if (!(claim in payload)) {
        throw new InvalidTokenError(`Missing '${claim}' claim`);
    }
    let actual = payload[claim];
    if (typeof actual === 'string') {
        actual = actual.split(' ');
    }
    else if (!Array.isArray(actual)) {
        return false;
    }
    actual = new Set(actual);
    return matchAll
        ? expected.every(Set.prototype.has.bind(actual))
        : expected.some(Set.prototype.has.bind(actual));
};
const requiredScopes$1 = (scopes) => {
    if (typeof scopes === 'string') {
        scopes = scopes.split(' ');
    }
    else if (!Array.isArray(scopes)) {
        throw new TypeError("'scopes' must be a string or array of strings");
    }
    const fn = isClaimIncluded('scope', scopes);
    return claimCheck$1((payload) => {
        if (!('scope' in payload)) {
            throw new InsufficientScopeError(scopes, "Missing 'scope' claim");
        }
        if (!fn(payload)) {
            throw new InsufficientScopeError(scopes);
        }
        return true;
    });
};
const scopeIncludesAny$1 = (scopes) => {
    if (typeof scopes === 'string') {
        scopes = scopes.split(' ');
    }
    else if (!Array.isArray(scopes)) {
        throw new TypeError("'scopes' must be a string or array of strings");
    }
    const fn = isClaimIncluded('scope', scopes, false);
    return claimCheck$1((payload) => {
        if (!('scope' in payload)) {
            throw new InsufficientScopeError(scopes, "Missing 'scope' claim");
        }
        if (!fn(payload)) {
            throw new InsufficientScopeError(scopes);
        }
        return true;
    });
};
const claimIncludes$1 = (claim, ...expected) => {
    if (typeof claim !== 'string') {
        throw new TypeError("'claim' must be a string");
    }
    expected.forEach(checkJSONPrimitive);
    return claimCheck$1(isClaimIncluded(claim, expected), `Unexpected '${claim}' value`);
};
const claimEquals$1 = (claim, expected) => {
    if (typeof claim !== 'string') {
        throw new TypeError("'claim' must be a string");
    }
    checkJSONPrimitive(expected);
    return claimCheck$1((payload) => {
        if (!(claim in payload)) {
            throw new InvalidTokenError(`Missing '${claim}' claim`);
        }
        return payload[claim] === expected;
    }, `Unexpected '${claim}' value`);
};
const claimCheck$1 = (fn, errMsg) => {
    if (typeof fn !== 'function') {
        throw new TypeError("'claimCheck' expects a function");
    }
    return (payload) => {
        if (!payload) {
            throw new UnauthorizedError();
        }
        if (!fn(payload)) {
            throw new InvalidTokenError(errMsg);
        }
    };
};

function resolveHost(req) {
    var _a, _b, _c;
    const trust = (_b = (_a = req.app) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, 'trust proxy fn');
    const get = typeof req.get === 'function' ? req.get.bind(req) : undefined;
    let host = get ? get('X-Forwarded-Host') : undefined;
    if (!host ||
        !(typeof trust === 'function' && trust((_c = req.socket) === null || _c === void 0 ? void 0 : _c.remoteAddress, 0))) {
        return get ? get('Host') : undefined;
    }
    const i = host.indexOf(',');
    if (i !== -1) {
        host = host.substring(0, i).trimEnd();
    }
    return host || undefined;
}

const auth = (opts = {}) => {
    const verifyJwt = jwtVerifier(opts);
    assertValidDPoPOptions(opts.dpop);
    return async (req, res, next) => {
        var _a;
        const { headers, query, body, method } = req;
        const url = `${req.protocol}://${resolveHost(req)}${(_a = req.originalUrl) !== null && _a !== void 0 ? _a : req.url}`;
        const requestOptions = {
            headers,
            url,
            method,
            query,
            body,
            isUrlEncoded: !!req.is('urlencoded'),
        };
        const verifier = tokenVerifier(verifyJwt, opts, requestOptions);
        try {
            req.auth = await verifier.verify();
            next();
        }
        catch (e) {
            if (opts.authRequired === false) {
                next();
            }
            else {
                next(verifier.applyAuthChallenges(e));
            }
        }
    };
};
const toHandler = (fn) => (req, res, next) => {
    var _a;
    try {
        fn((_a = req.auth) === null || _a === void 0 ? void 0 : _a.payload);
        next();
    }
    catch (e) {
        next(e);
    }
};
const claimCheck = (...args) => toHandler(claimCheck$1(...args));
const claimEquals = (...args) => toHandler(claimEquals$1(...args));
const claimIncludes = (...args) => toHandler(claimIncludes$1(...args));
const requiredScopes = (...args) => toHandler(requiredScopes$1(...args));
const scopeIncludesAny = (...args) => toHandler(scopeIncludesAny$1(...args));

exports.InsufficientScopeError = InsufficientScopeError;
exports.InvalidRequestError = InvalidRequestError;
exports.InvalidTokenError = InvalidTokenError;
exports.UnauthorizedError = UnauthorizedError;
exports.auth = auth;
exports.claimCheck = claimCheck;
exports.claimEquals = claimEquals;
exports.claimIncludes = claimIncludes;
exports.requiredScopes = requiredScopes;
exports.scopeIncludesAny = scopeIncludesAny;
